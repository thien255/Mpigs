//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface ITenantClient {
  manage(): Promise<FileResponse | null>;

  add(entity: TenantForm): Promise<ResultBaseOfTenant>;

  edit(entity: TenantForm): Promise<ResultBaseOfTenant>;

  delete(): Promise<FileResponse | null>;
}

export class TenantClient implements ITenantClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://localhost:7216";
  }

  manage(): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/Tenant/Manage";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      headers: {
        Accept: "application/octet-stream",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processManage(_response);
    });
  }

  protected processManage(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse | null>(null as any);
  }

  add(entity: TenantForm): Promise<ResultBaseOfTenant> {
    let url_ = this.baseUrl + "/Tenant/Add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAdd(_response);
    });
  }

  protected processAdd(response: Response): Promise<ResultBaseOfTenant> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ResultBaseOfTenant);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ResultBaseOfTenant>(null as any);
  }

  edit(entity: TenantForm): Promise<ResultBaseOfTenant> {
    let url_ = this.baseUrl + "/Tenant/Edit";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processEdit(_response);
    });
  }

  protected processEdit(response: Response): Promise<ResultBaseOfTenant> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ""
            ? null
            : (JSON.parse(
                _responseText,
                this.jsonParseReviver
              ) as ResultBaseOfTenant);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ResultBaseOfTenant>(null as any);
  }

  delete(): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/Tenant/Delete";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      headers: {
        Accept: "application/octet-stream",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDelete(_response);
    });
  }

  protected processDelete(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse | null>(null as any);
  }
}

export interface ResultBaseOfTenant {
  code: string;
  message: string;
  data?: Tenant | undefined;
  dataMessage: string;
}

export interface Tenant {
  id: number;
  code: string;
  shortName: string;
  name: string;
  description?: string | undefined;
  type: string;
  logo?: string | undefined;
  address?: string | undefined;
  phone?: string | undefined;
  representative?: string | undefined;
  license?: string | undefined;
  expired?: Date | undefined;
  email?: string | undefined;
  scale?: string | undefined;
  isActive?: boolean | undefined;
  isDelete: boolean;
  createdOn: Date;
  createdBy?: string | undefined;
  latestUpdatedOn?: Date | undefined;
  updatedBy?: string | undefined;
}

export interface TenantForm {
  id: number;
  code: string;
  shortName: string;
  name: string;
  description?: string | undefined;
  type: string;
  logo?: string | undefined;
  address?: string | undefined;
  phone?: string | undefined;
  representative?: string | undefined;
  expired?: Date | undefined;
  email?: string | undefined;
  scale?: string | undefined;
  isActive?: boolean | undefined;
}

export interface DataPagingResultOfUserViewModel {
  message: string;
  code: string;
  data: UserViewModel[];
  totalRows: number;
}

export interface UserViewModel {
  id: number;
  userName: string;
  email: string;
  phoneNumber: string;
  tenant: string;
  fullName: string;
  createBy: string;
  createdOn: string;
}

export interface UserManageRequest {
  startDate: string;
  endDate: string;
  search: string;
  tenant: string;
  status: number;
  sortDir: string;
  sortExpr: string;
  pageSize: number;
  pageIndex: number;
}

export interface ResultBaseOfUser {
  code: string;
  message: string;
  data?: User | undefined;
  dataMessage: string;
}

export interface User {
  id: number;
  userName: string;
  password?: string | undefined;
  fullName?: string | undefined;
  fistName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  emailConfirmed?: boolean | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean | undefined;
  twoFactorEnabled?: boolean | undefined;
  lockoutEnabled?: boolean | undefined;
  culture?: string | undefined;
  isActive: boolean;
  isDelete?: boolean | undefined;
  createdOn: Date;
  createdBy?: string | undefined;
  latestUpdatedOn?: Date | undefined;
  latestUpdatedBy?: string | undefined;
}

export interface UserForm {
  email: string;
  userName: string;
  lastName: string;
  firstName: string;
  password: string;
  phoneNumber: string;
}

export interface ResultBaseOfUserDetailViewModel {
  code: string;
  message: string;
  data?: UserDetailViewModel | undefined;
  dataMessage: string;
}

export interface UserDetailViewModel {
  user: User;
  roles: Role[];
  tenants: Tenant[];
}

export interface Role {
  key: string;
  description?: string | undefined;
  isDelete: boolean;
  createdOn: Date;
  createdBy: string;
}

export interface UserDeleteRequest {
  userId: number;
  username: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
